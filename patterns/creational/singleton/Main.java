package patterns.creational.singleton;

import patterns.creational.singleton.singleton.SimpleSingleton;
import patterns.creational.singleton.singleton.ThreadSafeSingleton1;
import patterns.creational.singleton.singleton.ThreadSafeSingleton2;
import patterns.creational.singleton.singleton.ThreadSafeSingleton3;


/* ОДИНОЧКА: гарантирует, что класс имеет только 1 экземпляр, и предоставляет глобальную точку
 * доступа к этому экземпляру
 *
 * - можно сказать, что класс нарушает "принцип одной обязанности" и имеет их две:
 *      - свою основную обязаность
 *      - обязанность по созданию и предоставлению себя
 *      - поэтому некоторые разработчики выносят функционал Одиночки в отдельную абстракцию */


/* ПРИМЕНЕНИЕ
 * - когда должен быть единственный экземпляр какого-то класса, доступный всем клиентам
 *      - например, общий доступ к базе данных из разных частей программы
 *
 * - когда хочется иметь больше контроля над глобальными переменными */


/* ПЛЮСЫ
 * - гарантирует наличие единственного экземпляра класса
 * - предоставляет к нему глобальную точку доступа
 * - реализует отложенную инициализацию объекта-одиночки */


/* МИНУСЫ
 * - нарушает принцип единственной ответственности класса
 * - маскирует плохой дизайн
 * - проблемы мультипоточности
 * - требует постоянного создания Mock-объектов при юнит-тестировании */


/* СУТЬ РЕАЛИЗАЦИИ
 * - конкретный синглтон: определяет статический метод getInstance(), который возвращает
 * единственный экземпляр своего класса
 *      - например, класс подключения к базе данных
 *      - конструктор должен быть скрыт от клиентов
 *          - вызов метода getInstance() должен стать единственным способом получить объект этого
 *          класса
 *      - переменная экземпляра
 *      - (опционально) другой код класса */


/* ОДИНОЧКА VS ГЛОБАЛЬНАЯ ПЕРЕМЕННАЯ
 * - оба предоставляют глобальный доступ к экземпляру класса
 *      - но О также гарантирует существование одного экземпляра
 * - О предоставляет возможность отложенной инициализации
 * - глобальные переменные засоряют пространство имен множеством глобальных ссылок на мелкие объекты */


/* ПРОБЛЕМЫ МНОГОПОТОЧНОСТИ
 * - если 2 потока обратятся к методу getInstance(), то есть вероятность, что для обоих еще не будет
 * существовать экземпляра, поэтому будет создано 2 экземпляра
 *
 * - решение:
 *      1 - статическая инициализация переменной:
 *          - лишает возможности отложенной инициализации
 *          - но и нет необходимости делать в методе проверку на существование экземпляра
 *
 *      2 - синхронизированный метод
 *          - весь метод становится synchronized
 *          - работа метода замедляется в 100 раз
 *              - не подходит для частого использования
 *
 *      3 - синхронизированный блок в методе в месте создания экземпляра
 *          - синхронизирован только тот код, который производит создание экземпляра
 *          - переменная должна быть volatile
 *              - гарантирует, что параллельные потоки будут правильно работать с переменной при ее
 *              инициализации экземпляром
 *          - не работает ниже версии 1.5 */


/* ПРОБЛЕМЫ НАСЛЕДОВАНИЯ
 * - из-за приватного конструктора
 *      - но иначе другие классы смогут создавать его экземпляр
 *
 * - при прямолинейном наследовании все наследники будут совместно использовать одну статическую
 * переменную экземпляра
 *      - тогда придется реализовывать в базовом классе некое подобие системы управлления доступом
 *
 * - поэтому лучше избегать частого использования О в архитектуре программы */


public class Main {

    public static void main(String[] args) {
        SimpleSingleton simpleSingleton = SimpleSingleton.getInstance();
        ThreadSafeSingleton1 threadSafeSingleton = ThreadSafeSingleton1.getInstance();
        ThreadSafeSingleton2 threadSafeSingleton2 = ThreadSafeSingleton2.getInstance();
        ThreadSafeSingleton3 threadSafeSingleton3 = ThreadSafeSingleton3.getInstance();
    }
}