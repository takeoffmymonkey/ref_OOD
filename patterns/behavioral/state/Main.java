package patterns.behavioral.state;


/* СОСТОЯНИЕ: позволяет объектам менять поведение в зависимости от своего состояния
 * - извне создаётся впечатление, что изменился класс объекта
 *      - т.к. полностью изменилось поведение, это похоже на уже другой объект
 *
 * - можно рассматривать как надстройку над Стратегией:
 *      - оба паттерна используют композицию, чтобы менять поведение основного объекта, делегируя
 *      работу вложенным объектам-помощникам
 *          - но в Стратегии эти объекты не знают друг о друге и никак не связаны
 *          - а в Состоянии сами конкретные состояния могут переключать контекст */


/* ПРИМЕНЕНИЕ
 * - когда есть объект, поведение которого кардинально меняется в зависимости от внутреннего
 * состояния, причём типов состояний много, и их код часто меняется
 *
 * - когда код класса содержит множество больших, похожих друг на друга, условных операторов,
 * которые выбирают поведения в зависимости от текущих значений полей класса
 *
 * - когда вы сознательно используете табличную машину состояний, построенную на условных операторах,
 * но вынуждены мириться с дублированием кода для похожих состояний и переходов */


/* ПЛЮСЫ
 * - избавляет от множества больших условных операторов машины состояний
 *
 * - концентрирует в одном месте код, связанный с определённым состоянием
 *
 * - упрощает код контекста */


/* МИНУСЫ
 * - может неоправданно усложнить код, если состояний мало и они редко меняются */


/* СУТЬ РЕАЛИЗАЦИИ
 * - КОНТЕКСТ: хранит ссылку на объект состояния и делегирует ему часть работы, зависящей от состояний
 *      - например, "автомат продажи жевачек"
 *      - работает с этим объектом через общий интерфейс состояний
 *      - должен иметь метод для присваивания ему нового объекта-состояния
 *      - если переходы между состояниями "статичны", то их стоит размещать в контексте, если
 *      "динамичны" (например, зависят от количества шариков), то их лучше размещать в самом классе
 *      состояния, но тогда возникают зависимости между классами состояний
 *
 * - СОСТОЯНИЕ: описывает общий интерфейс для всех конкретных состояний
 *      - могут использоваться сразу несколькими контекстами
 *
 * - КОНКРЕТНЫЕ СОСТОЯНИЯ: реализуют поведения, связанные с определённым состоянием контекста
 *      - например, "состояние без монеты", "состояние все жевачки проданы" и т.д.
 *      - иногда приходится создавать целые иерархии классов состояний, чтобы обобщить дублирующий
 *      код
 *      - состояние может иметь обратную ссылку на объект контекста
 *          - через неё не только удобно получать из контекста нужную информацию, но и осуществлять
 *          смену его состояния
 *
 * - И КОНТЕКСТ, и объекты КОНКРЕТНЫХ СОСТОЯНИЙ могут решать, когда и какое следующее состояние
 * будет выбрано
 *      - чтобы переключить состояние, нужно подать другой объект-состояние в контекст */


import patterns.behavioral.state.context.GumballMachine;

public class Main {

    public static void main(String[] args) {
        GumballMachine gumballMachine = new GumballMachine(5);

        gumballMachine.turnCrank(); // Вы дернули ручку, но монетка еще не брошена
        gumballMachine.insertQuater(); // Вы бросили монетку
        gumballMachine.ejectQuater(); // Возвращаю монету
        gumballMachine.turnCrank(); // Вы дернули ручку, но монетка еще не брошена
        gumballMachine.insertQuater(); // Вы бросили монетку
        gumballMachine.releaseBall(); // Шарик жевачки выкатывается из слота
    }
}