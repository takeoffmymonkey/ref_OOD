package patterns.behavioral.template_method;

import patterns.behavioral.template_method.concrete_class.Coffee;
import patterns.behavioral.template_method.concrete_class.Tea;


/* ШАБЛОННЫЙ МЕТОД: задает "скелет" алгоритма в методе, оставляя определение реализации некоторых
 * шагов субклассам. Субклассы могут переопределить некоторые части алгоритма без изменения его
 * структруры
 *
 * - является примером "Голливудского принципа" - компоненты более низкого уровня не обращаются к
 * более высокого
 *
 * - один из наиболее используемых паттернов */


/* ПРИМЕНЕНИЕ
 * - когда подклассы должны расширять базовый алгоритм, не меняя его структуры
 *
 * - когда у вас есть несколько классов, делающих одно и то же с незначительными отличиями
 *      - если вы редактируете один класс, то приходится вносить такие же правки и в остальные классы */


/* ПЛЮСЫ
 * - облегчает повторное использование кода */


/* МИНУСЫ
 * - жёсткое ограничение скелетом существующего алгоритма
 *
 * - можно нарушить принцип подстановки Барбары Лисков, изменяя базовое поведение одного из шагов
 * алгоритма через подкласс
 *
 * - с ростом количества шагов шаблонный метод становится слишком сложно поддерживать */


/* СУТЬ РЕАЛИЗАЦИИ
 * - абстрактный класс: определяет шаги алгоритма и содержит шаблонный метод, состоящий из вызовов
 * этих шагов
 *      - например, "напиток с кофеином" с шаблонным методом "приготовление напитка"
 *      - шаги могут быть как абстрактными, так и содержать реализацию по умолчанию
 *      - сам шаблонный метод и другие неабстрактные методы, участвующие в алгоритме, объявляются
 *      как final, чтобы субклассы не могли изменить последовательность и независящее от них
 *      поведение алгоритма
 *      - (опционально) в алгоритме в разных местах могут быть методы-перехватчики
 *          - объявлены в суперклассе и имеют пустое тело либо дефолтную реализацию
 *          - подклассы МОГУТ их переопределять при желании
 *          - позволяют подклассам "подключаться" к алгоритму в разных точках либо создавать сложную
 *          логику в алгоримте
 *
 * - конкретный класс: переопределяет некоторые (или все) шаги алгоритма
 *      - например, "чай", "кофе", которые переопределяют методы "заварить" и "добавить дополнение"
 *      - конкретные классы не переопределяют сам шаблонный метод */


public class Main {

    public static void main(String[] args) {
        new Coffee().prepare();
        new Tea().prepare();
    }
}
