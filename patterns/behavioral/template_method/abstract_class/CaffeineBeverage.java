package patterns.behavioral.template_method.abstract_class;


/* АБСТРАКТНЫЙ КЛАСС: определяет шаги алгоритма и содержит шаблонный метод, состоящий из вызовов
 * этих шагов
 *
 * - шаги могут быть как абстрактными, так и содержать реализацию по умолчанию
 *
 * - сам шаблонный метод и другие неабстрактные методы, участвующие в алгоритме, объявляются как
 * final, чтобы субклассы не могли изменить последовательность и независящее от них поведение
 * алгоритма
 *
 * - (опционально) в алгоритме в разных местах могут быть методы-перехватчики
 *      - объявлены в суперклассе и имеют пустое тело либо дефолтную реализацию
 *      - подклассы МОГУТ их переопределять при желании
 *      - позволяют подклассам "подключаться" к алгоритму в разных точках либо создавать сложную
 *      логику в алгоримте */


public abstract class CaffeineBeverage {
    final public void prepare() { // шаблонный метод
        boilwater();
        brew(); // абстрактный метод для переопределения наследником
        pourInCup();
        if (customerWantsCondiments()) { // усложненная логика с методом-перехватчиком
            addCondiments(); // абстрактный метод для переопределения наследником
        }
    }


    final void boilwater() {
        System.out.println("Boiling water");
    }


    public abstract void brew();


    final void pourInCup() {
        System.out.println("Pouring into cup");
    }


    public boolean customerWantsCondiments() { // метод-перехватчик можно переопредлять в подклассе
        return true; // дефолтная реализация
    }

    public abstract void addCondiments();
}