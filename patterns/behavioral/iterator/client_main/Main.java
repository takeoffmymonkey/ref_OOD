package patterns.behavioral.iterator.client_main;

import patterns.behavioral.iterator.collection_item.MenuItem;
import patterns.behavioral.iterator.abstract_iterator.Iterator;
import patterns.behavioral.iterator.concrete_collection.DinerMenu;
import patterns.behavioral.iterator.concrete_collection.PancakeHouseMenu;


/* ИТЕРАТОР: предоставляет механизм последовательного перебора элементов коллекции без раскрытия ее
 * внутреннего представления
 *
 * - ответственность за перебор элементов коллекции передается от объекта коллекции объекту итератора
 *
 * - java.util.Iterator - готовый интерфейс итератора в Java
 *
 * - коллекции имеют свои реализации итераторов, который можно получить методом iterator() */


/* ПРИМЕНЕНИЕ
 * - когда есть сложная структура данных, и вы хотите скрыть от клиента детали её реализации (из-за
 * сложности или вопросов безопасности)
 *
 * - когда нужно иметь несколько вариантов обхода одной и той же структуры данных
 *
 * - когда хочется иметь единый интерфейс обхода различных структур данных */


/* ПЛЮСЫ
 * - упрощает классы хранения данных
 *
 * - позволяет реализовать различные способы обхода структуры данных
 *
 * - позволяет одновременно перемещаться по структуре данных в разные стороны */


/* МИНУСЫ
 * - не оправдан, если можно обойтись простым циклом */


/* СУТЬ РЕАЛИЗАЦИИ
 * - АБСТРАКТНЫЙ ИТЕРАТОР: описывает интерфейс для доступа и обхода элементов коллекции
 *
 * - КОНКРЕТНЫЙ ИТЕРАТОР: реализует алгоритм обхода какой-то конкретной коллекции
 *      - объект итератора должен сам отслеживать текущую позицию при обходе коллекции, чтобы
 *      отдельные итераторы могли обходить одну и ту же коллекцию независимо
 *
 * - АБСТРАКТНАЯ КОЛЛЕКЦИЯ: описывает интерфейс получения итератора из коллекции
 *     - коллекции не всегда являются списком: это может быть и база данных, и удалённое API, и
 *     даже дерево Компоновщика
 *         - поэтому сама коллекция может создавать итераторы, так как она знает, какие именно
 *         итераторы способны с ней работать
 *
 * - КОНКРЕТНАЯ КОЛЛЕКЦИЯ: возвращает новый экземпляр определённого конкретного итератора, связав
 * его с текущим объектом коллекции
 *      - сигнатура метода возвращает интерфейс итератора, что позволяет клиенту не зависеть от
 *      конкретных классов итераторов
 *
 * - КЛИЕНТ: работает со всеми объектами через интерфейсы коллекции и итератора
 *      - так клиентский код не зависит от конкретных классов, что позволяет применять различные
 *      итераторы, не изменяя существующий код программы */


/* КЛИЕНТ */
public class Main {

    public static void main(String[] args) {
        DinerMenu dinerMenu = new DinerMenu();
        Iterator iterator = dinerMenu.createIterator();
        while (iterator.hasNext()) {
            MenuItem menuItem = (MenuItem) iterator.next();
            System.out.println("Name: " + menuItem.getName());
            System.out.println("Price: " + menuItem.getPrice());
        }


        PancakeHouseMenu pancakeHouseMenu = new PancakeHouseMenu();
        java.util.Iterator iterator1 = pancakeHouseMenu.createIterator();
        while (iterator1.hasNext()) {
            MenuItem menuItem = (MenuItem) iterator1.next();
            System.out.println("Name: " + menuItem.getName());
            System.out.println("Price: " + menuItem.getPrice());
        }
    }
}