package patterns.behavioral.strategy;

import patterns.behavioral.strategy.abstract_client.Duck;
import patterns.behavioral.strategy.concrete_algorythm_fly.NoFly;
import patterns.behavioral.strategy.concrete_algorythm_fly.NormalFly;
import patterns.behavioral.strategy.concrete_algorythm_quack.NoQuack;
import patterns.behavioral.strategy.concrete_algorythm_quack.NormalQuack;
import patterns.behavioral.strategy.concrete_client.MallardDuck;
import patterns.behavioral.strategy.concrete_client.RubberDuck;

/* СТРАТЕГИЯ
 * - определяет семейство алгоритмов
 * - инкапсулирует и обеспечивает их взаимозаменяемость
 * - позволяет модифицировать алгоритмы независимо от их использования на стороне клиента */


/* ПРИМЕНИМОСТЬ
 * - когда нужно использовать разные вариации какого-то алгоритма внутри одного объекта
 * - когда есть множество похожих классов, отличающихся только некоторым поведением
 * - когда не хотите обнажать детали реализации алгоритмов для других классов
 * - когда различные вариации алгоритмов реализованы в виде развесистого условного оператора
 *      - каждая ветка такого оператора представляет собой вариацию алгоритма */


/* ПЛЮСЫ
 * - горячая замена алгоритмов на лету
 * - изолирует код и данные алгоритмов от остальных классов
 * - уход от наследования к делегированию
 * - реализует принцип открытости/закрытости */


/* МИНУСЫ
 * - усложняет программу за счёт дополнительных классов
 * - клиент должен знать, в чём состоит разница между стратегиями, чтобы выбрать подходящую */


/* СУТЬ РЕАЛИЗАЦИИ
 * - абстракция клиента, который будет выполнять какие-то поведения
 *      - например, "утка"
 *      - хранит ссылку на абстракцию каждого типа поведения
 *          - например, "полет" или "кряканье"
 *          - имеет методы для смены объектов по этим ссылкам динамически
 *      - имеет методы для вызова соответствующих методов выполнения поведения на абстракциях
 *      поведения (соррян)
 *          - например, метод "выполнитьКряк()", который вызывает метод "крякнуть()" на абстракции
 *          типа "кряканье"
 *
 * - абстракции какого-то поведения (алгоритма)
 *      - например, "полет" или "кряканье"
 *      - имеет абстрактный метод для выполнения своего поведения
 *          - например, "крякнуть()"
 *          - этот метод будет вызван соответствующим методом из абстракции клиента
 *              - например, метод "выполнитьКряк()", который вызывает "крякнуть()"
 *
 * - конкретный клиент
 *      - например, "дикая утка"
 *      - в конструкторе может задаваться конкретное поведение "полет" или "кряканье" для данной
 *      конкретной реализации "утки"
 *          - например, "полет" = new NormalFly();
 *      - во время работы поведение можно менять
 *          - например, "изменитьТипПолета(new NoFly())"
 *
 * - конкретное поведение
 *      - например, "нормально крякнуть" или "невозможность крякать"
 *      - представляет свою реализацию метода "крякнуть()"
 *      - при создании конкретного клиента, его полям с абстрактными поведениями присвавиваются
 *      конкретные поведения, чтобы сформировать реальное поведение данного объекта клиента */


public class Main {

    public static void main(String[] args) {
        Duck d1 = new MallardDuck();
        d1.performFly(); // I can fly with wings
        d1.performQuack(); // Quack!
        d1.setQuackBehavior(new NoQuack()); // динамическая смена поведения
        d1.setFlyBehavior(new NoFly()); // динамическая смена поведения
        d1.performFly(); // I can't fly at all
        d1.performQuack(); // ...

        Duck d2 = new RubberDuck();
        d2.performFly(); // I can't fly at all
        d2.performQuack(); // ...
        d2.setQuackBehavior(new NormalQuack()); // динамическая смена поведения
        d2.setFlyBehavior(new NormalFly()); // динамическая смена поведения
        d2.performFly(); // I can fly with wings
        d2.performQuack(); // Quack!
    }
}