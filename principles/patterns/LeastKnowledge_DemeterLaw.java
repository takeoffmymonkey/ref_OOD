package principles.patterns;


/* НАИМЕНЬШЕЕ ЗНАНИЕ: КЛАСС ДОЛЖЕН ЗНАТЬ И ВЗАИМОДЕЙСТВОВАТЬ С НАИМЕНЬШИМ КОЛИЧЕСТВОМ ДРУГИХ КЛАССОВ
 * - взаимодействие между объектами необходимо сокращать до нескольких "близких друзей":
 *      - нельзя вызывать методы объектов, полученных в результате вызова других методов
 *      - для любого объекта в его методах можно вызывать только методы, которые принадлежат:
 *          - самому объекту
 *          - объекту, переданному в качестве параметра
 *          - любому объекту, созданному внутри метода
 *          - любым компонентам объекта
 *              - т.е. объекты классов, которые объект содержит в качестве своих полей
 *          - т.е. метод не должен обращаться к другому методу "дотягиваясь до него" через объект
 *
 *      - возвращаемый методом тип должен быть тот же, что:
 *          - объявленный в параметре метода
 *          - объявленный и инициализированный внутри метода
 *          - объявленный внутри класса, которому принадлежит метод
 *
 * - снижает уровень связанности
 *
 * - пример БЕЗ принципа:
 *      float getTemp(){
 *          Thermometer t = station.getTermometer(); // сначала получаем термометр
 *          return t.getTemperature(); // на нем вызываем метод
 *      }
 *
 * - пример с принципом:
 *      float getTemp(){
 *          // не нужно создавать объект термометра, т.е. от него больше не зависим
 *          return station.getTemperature(); // у станции есть метод получения температуры
 *      } */


public class LeastKnowledge_DemeterLaw {

    /* КЛАСС, СООТВЕТСТВУЮЩИЙ ПРИНЦИПУ ОБЩЕНИЯ ТОЛЬКО С ДРУЗЬЯМИ */
    class OnlyFriendsExample {
        Engine engine;

        void start(Key key) {
            Doors doors = new Doors(); // можно создавать объекты внутри

            key.turns(); // можно использовать методы переданного параметра
            engine.start(); // можно использовать методы компонента
            doors.lock(); // можно использовать методы созданного внутри метода объекта
        }
    }


    class Engine {
        void start() {
        }
    }

    class Key {
        void turns() {
        }
    }

    class Doors {
        void lock() {
        }
    }
}